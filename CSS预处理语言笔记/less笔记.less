/*
     Less是 css预处理语言。变量+运算、mixin（混合）、函数、嵌套等。让网页开发的css更容易维护，从而提高开发效率。
        注意：在css中使用的 @import（引入外部文件css/less）css3新特性 ... less里面都可以使用
     全局安装:(首先要有nodejs环境、npm环境)
        $  cnpm i less -g 
        $  npm i less -g
        !!!(mac系统:加上sudo)
    下载完毕后：查看less版本 lessc -v

    less 不能直接运行 要编译撑css文件才能运行：
     编译less文件的五类方式、用第三种/第五种
        第一种：$ lessc style.less 
                但是这样有点问题 编译后在命令行 直接copy？？？

        第二种：$ lessc index.less index.css 
                编译后生成一个规定的文件名的css文件

        第三种：百度上面下载koala => 直接使用koala程序编译less文件 可以监听less文件变化，自动编译
            还可以生成资源地图文件 
            source map 生成的文件.map，可以让浏览器追踪到less文件的错误什么的位置

        第四种、webstorm（WS）的使用 试用webstorm编辑器配置编辑.

        第五种、直接在vscode插件搜索less 会找到对应的一个插件Easy LESS 安装后自动编译
*/

/*
    less的语法：
        注释、变量、混合、匹配模式、颜色函数、嵌套等.
        1 注释 (单行注释编译撑css文件的时候不保留)
            单行注释：//
            多行注释:/* */

/*
        2 变量+运算
            2.1.变量的好处
            把重复使用css属性值定义成变量、可以重复使用，方便后期css代码的维护.
            2.2.变量的定义
            定义变量的语法 @变量名:变量的值（css的属性值）
            2.3.变量的使用
            属性名称:@变量名
            2.4.字符串拼接别的 路径等
            字符串拼接 {}包了变量名 不包@这个定义变量的符号

            2.5定义一个变量 全局变量 
                @width:1000px;
                @height:600px;
                @border:1px solid @color;
                @margin:0 auto;
                @imgUrl:"../images/";
                @color:rgba(0,0,0,.5);
                @size:20px;
                //定义选择器
                @container:.container
                @{container}{ //嵌套方式 
                    //写css样式
                    width:@width;
                    margin:@margin;
                    a{
                        font-size:@size;
                    }
                }
                //试用如下
                body{
                    字符串拼接 {}包了变量名 不包@ 
                    background-image: url("@{imgUrl}bg.png");
                    color:@color;
                    //局部变量 只能在这个css作用域内部试用
                    @lineHeight:2em;
                    line-height:@lineHeight;
                }
            2.6 同时变量或者直接定义的数值都可以参与运算（记得运算符的左右加上空格、防止出错）（运算只涉及 加 减 乘 除 ）
                例如：@size + 10px 、@size - 10px 、@size / 2 、@size * 2

            2.7 运算的注意点、运算的单位等要相同，百分比不能和px计算、颜色16进制格式不能和rgb等一起运算、字符串只能相加拼接等。
                注意事项：
                    如果是@border:1px solid @color;
                        @border + 1px solid #111; => 这样的就运算不了 报错
*/
/*
        3.混合mixin 封装公共的css代码 类似于函数
            3.1 什么是mixins 简单理解就是函数 可以封装css代码，在别的选择器中调用，提高代码的复用性和维护性 
            3.2 定义混合的语法：
                3.2.1 普通 不带参数
                .混合名(){
                    //封装的css代码
                }
                3.2.2 带参数的混合
                .混合名(@参数名称:默认值){
                    //封装的css代码
                }
            3.3.调用混合?
            h1{
                .混合名称();
                // 或者
                .混合名称(参数的值);
                //或者 给指定的参数传值
                .混合名称(@参数名称:参数的值);
            }
*/
/*
       4.匹配模式
            根据条件进行样式显示 类似js的switch

           4.1模式匹配的含义、相当于定义相同的混合名称，根据分支的值决
                定执行按个分支,但是有一个公共的分支（任何一个分支都会调用）@_(@_表示匹配所有)

           4.1.1 模式匹配的定义和使用形式
                定义：
            .fun(@_,@color){
                //任何分支都会执行的公共部分
            }
            .fun(s1,@color){
                // 传入s1的时候执行的分支部分
            }
            .fun(s2,@color){
                // 传入s2的时候执行的分支部分
            }
                使用：
            h1{
                .fun(s2,@color);//使用了s2的代码和公共部分的代码
            }

*/
/*
         (内置函数)
         5 颜色函数(颜色三要素，色相(颜色的名称)，饱和度(鲜艳程度)，明亮度(亮度，明暗程度)

            lighten(@color,10%);//比@color亮10%的颜色 上下(饱和度，鲜艳程度)
            darken(@color,10%);//比@color暗10%的颜色

            saturate(@color,10%);//比@color浓10%的颜色 左右(亮度，明度)
            desaturate(@color,10%);//比@color淡10%的颜色

            spin(@color,10) //色相值增加10 颜色变化 红->橙->黄->...->红 就是颜色的名称
            spin(@color,-10)//色相减少10

            mix(@color1,@color2);//混合两种颜色

*/
/*
        6 嵌套
            具有层级关系的css样式，css的层级最终由html的结构定义的。
            嵌套使用在具有层级关系的选择器中，减少代码量
            爷爷容器{
                //爷爷自己的样式等。。。
                父亲容器{
                    //父亲自己的样式
                    我的容器{
                        //自己的样式
                        儿子的容器{
                            //自己儿子的样式
                            。。。
                        }
                    }
                }
                母亲容器{
                    //母亲自己的样式
                    我的弟弟的容器{
                        //弟弟自己的样式
                        ...
                    }
                }
            }

*/